{"version":3,"sources":["client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"eb4c23d32420d9276fb9d3672b7ddcc2.map","sourcesContent":["var client_id = '5lch5g05xtkp5zhfva8g3u1xlxzwvb'\n\n/**\n * Dictionary for mapping query types to their respective paths on the API\n */\nvar routes = {\n  'search': {\n    path: 'kraken/search/streams'\n  }\n}\n\n/**\n * App - Main 'App' Object\n * @param  {Object} dom          Defaults to `document` if not provided.  Allows for mocking/stubbing\n * @param  {String} cb_signature Defaults to `window.jitters._fetched`.  This is the callback name we send to the api\n * @return {Object}              New 'App' with default state (empty result set)\n */\nfunction App(dom, cb_signature) {\n  this.default_timeout = 5000\n  this.state = { results: null,\n         current_request: null,\n            current_page: null }\n\n  if (typeof cb_signature !== 'undefined') { this.cb_signature = cb_signature }\n  else { this.cb_signature = 'window.jitters._fetched' }\n\n  if (typeof dom !== 'undefined') { this.dom = dom }\n  else { this.dom = document }\n\n  configureForm(this)\n}\n\n\n/**\n * var configureForm - Used to configure the search form after the App is initalized\n *\n * @param  {App} app The app injects itself as an argument here\n */\nvar configureForm = function(app) {\n\n  /// Function for validating input and executing the search\n  var checkAndSubmit = function(app) {\n    var value = app.dom.getElementById('search-input').value\n    if (!value.isEmpty()) {\n      app.state.current_page = null\n      app.search(value)\n    }\n  }\n\n  /// Bind click events to the submit button\n  var submitBtn = app.dom.getElementById('submit')\n  if (submitBtn) {\n    submitBtn.addEventListener('click', function() {\n      checkAndSubmit(app)\n    })\n  }\n\n  /// Bind 'enter' events to the search input\n  var input = app.dom.getElementById('search-input')\n  if (input) {\n    input.addEventListener('keyup', function(e) {\n      e.preventDefault()\n      if (event.keyCode === 13) {\n        checkAndSubmit(app)\n      }\n    })\n  }\n}\n\n\n/**\n * String.prototype.isEmpty - Prototype for checking for empty/blank strings\n *\n * @return {Boolean}  Is the string blank or not?\n */\nString.prototype.isEmpty = function() {\n    return (this.length === 0 || !this.trim());\n}\n\n/**\n * App.prototype.search - Perform a search on the API and render the result set in the API\n *\n * @param  {String} query A string describing what you're searching for\n */\nApp.prototype.search = function(query) {\n  var url    = url_for('search', {q: query,\n                          client_id: client_id,\n                           callback: this.cb_signature})\n  this._fetch(url)\n}\n\n/**\n * App.prototype._fetch - Used to make JSONP requests.\n *                        Works by creating a script element and appending it to the dom.\n *                        Mutates requests array for in flight tracking.\n *\n * @param  {String} url JSONP endpoint you would like to request data from\n */\nApp.prototype._fetch = function(url) {\n  setLoaderVisibility(this.dom, true)\n  this.error        = null\n\n  var skript        = this.dom.createElement('script')\n  if (!url.includes(\"client_id\")) { url = url + `&client_id=${client_id}` }\n  if (!url.includes(\"callback\")) { url = url + `&callback=${this.cb_signature}` }\n\n  skript.src        = url\n  skript.id         = string_to_hash(url)\n  this.dom.body.appendChild(skript)\n  this.state.current_request = url\n\n  /// Setup the timeout handler\n  var self = this\n  setTimeout(function() {\n    handleTimeoutForRequest(self, url)\n  }, this.default_timeout)\n}\n\n\n/**\n * var handleTimeoutForRequest - Timeout handler.\n *                               JSONP is fickle with error handling so we have\n *                               a timeout that we use to check if a request has\n *                               completed or not in a reasonable amount of time.\n *\n * @param  {type} app description\n * @param  {type} url description\n * @return {type}     description\n */\nvar handleTimeoutForRequest = function(app, url) {\n  var req = app.state.current_request\n  if (req && req == url) {\n    app.error                 = 'Could not connect to api'\n    app.state.current_request = null\n    app._removeRequestForID(string_to_hash(url))\n    app._updateUI({})\n    setLoaderVisibility(app.dom, false)\n  }\n}\n\n/**\n * var setLoaderVisibility - Function that explicitly sets the state of the loader\n *\n * @param  {Object} dom        Object used to represent the DOM\n * @param  {Boolean} visibility Whether the loader should be hidden or not\n */\nvar setLoaderVisibility = function(dom, visibility) {\n  var elems = dom.getElementsByClassName('loader')\n  var state = visibility == true ? 'visible' : 'hidden'\n  for (var i = 0; i < elems.length; i++) {\n    elems[i].style.visibility = state\n  }\n}\n\n/**\n * App.prototype._removeRequestForID - Remove the script element responsible for making a JSONP request.\n *                                     This happens when a request has timed out and should cancel it.\n *\n * @param  {String} request_id ID of the request.  This is just a hash of the url\n */\nApp.prototype._removeRequestForID = function(request_id) {\n  var requestElement = this.dom.getElementById(request_id)\n  if (requestElement) { requestElement.remove() }\n}\n\n/**\n * App.prototype._fetched - Used by the JSONP callback whenever a remote resource is loaded\n *\n * @param  {Object} data Results from the API. (https://dev.twitch.tv/docs/v5/reference/search/#search-streams)\n */\nApp.prototype._fetched = function(data) {\n  this.state.results          = data\n  this.state.current_request  = null\n  this.error                  = null\n  if (this.state.results) {\n    if (this.state.results._total > 0) {\n      this._updateUI(this.state.results)\n    } else {\n      var elem = this.dom.getElementById('results')\n      if (elem) { elem.innerHTML = error_template(\"Your search had no results.\") }\n\n      elem = this.dom.getElementById('results-controls')\n      if (elem) { elem.innerHTML = \"\" }\n    }\n  }\n  setLoaderVisibility(this.dom, false)\n}\n\n/**\n * App.prototype._updateUI - Called when the app should update it user interface\n *\n */\nApp.prototype._updateUI = function(results) {\n  if (this.error) {\n    var elem = this.dom.getElementById('results')\n    if (elem) { elem.innerHTML = error_template(this.error) }\n  } else {\n    if (!this.state.current_page) { this.state.current_page = 1  }\n\n    addTotalCount(this.dom, results)\n    addPagingControls(this.dom, results, this.state.current_page)\n    addResults(this.dom, results)\n  }\n}\n\n\n/**\n * var addResults - Takes an array of results and appends them to a section of the DOM\n *\n * @param  {Object} dom    This can be the document or any object you're using as a stub\n * @param  {Object} results An object returned by the twitch api\n */\nvar addResults = function(dom, results) {\n  if (results.streams && results.streams.length > 0) {\n      dom.getElementById('results').innerHTML = results.streams.map(build_result).join('')\n  }\n}\n\n\n/**\n * var addTotalCount - Updates the total count of results in the UI\n *\n * @param  {Object} dom     This can be the document or any object you're using as a stub\n * @param  {Object} results An object returned by the twitch api\n */\nvar addTotalCount = function(dom, results) {\n  if (results._total) {\n    dom.getElementById('results-controls').innerHTML = `<span class='total-results'>Total: ${results._total}</span>`\n  }\n}\n\n\n/**\n * var addPagingControls - Builds the DOM element containing pagination controls\n *\n * @param  {Object}  dom          This can be the document or any object you're using as a stub\n * @param  {Object}  results      An object returned by the twitch api\n * @param  {Integer} current_page A number representing the current page we're on\n */\nvar addPagingControls = function(dom, results, current_page) {\n  if (results._total) {\n    var node        = document.createElement(\"span\")\n    node.className  = 'paging-controls'\n    node.innerHTML  = buildPagerLinks(results._links, results._total, current_page)\n    dom.getElementById('results-controls').appendChild(node)\n  }\n}\n\n\n/**\n * var buildPagerLinks - Checks the links object in the results to build appropriate paging controls\n *\n * @param  {Object} links      links object found in the response from the API\n * @param  {Integer} total     Number representing ALL the results twitch has for this query\n * @param  {Integer} current_page Current Page number we're on\n */\nvar buildPagerLinks = function(links, total, current_page) {\n  var result = []\n  if (links.prev) { result.push(buildPageLink('prev')) }\n  if (links.self) { result.push(buildCurrentTotalPageInfo(current_page, total))}\n  if (links.next) {\n    if (parseOffsetFromLink(links.next) < total) {\n      result.push(buildPageLink('next'))\n    }\n  }\n  return result.join(' ')\n}\n\n\n/**\n * var buildPageLink - Builds an html link used for querying the\n *\n * @param  {type} direction description\n * @param  {type} link      description\n * @return {type}           description\n */\nvar buildPageLink = function(direction, link) {\n  if (direction == 'prev') {\n    return `<a href='#' onclick=\"window.jitters.fetch_prev()\">&#8678;</a>`\n  } else {\n    return `<a href='#' onclick=\"window.jitters.fetch_next()\">&#8680;</a>`\n  }\n}\n\n\n/**\n * var buildCurrentTotalPageInfo - Builds a string for use in displaying the page info\n *\n * @param  {Integer} current_page Page of results the user is currently on\n * @param  {Integer} total        Number of pages total\n * @return {String}               String following format: `1/12`\n */\nvar buildCurrentTotalPageInfo = function(current_page, total) {\n  var template = `${current_page}/${page_count(total)}`\n  return template\n}\n\n\n/**\n * var parseOffsetFromLink - Pulls the offset number out of a link\n *\n * @param  {String} link URL on the twitch api that possible contains an offset query param\n * @return {Integer}     If param is present returns the integer for it, otherwise null\n */\nvar parseOffsetFromLink = function(link) {\n  var matches = link.match(/offset=(\\d+)/)\n  if (matches && matches.length > 0) {\n    return parseInt(matches[1])\n  }\n  return null\n}\n\n/**\n * App.prototype.fetch_next - Proceed to the next page\n *\n */\nApp.prototype.fetch_next = function() {\n  this.fetch_page('next')\n}\n\n\n/**\n * App.prototype.fetch_prev - Proceed to the previous page\n *\n */\nApp.prototype.fetch_prev = function() {\n  this.fetch_page('prev')\n}\n\n\n/**\n * App - Used to make page fetch requests\n *\n * @param  {String} direction 'next' or 'prev'\n */\nApp.prototype.fetch_page = function(direction) {\n  var results = this.state.results\n  if (direction == 'next') {\n    this.state.current_page += 1\n    this._fetch(results._links.next)\n  } else {\n    this.state.current_page -= 1\n    this._fetch(results._links.prev)\n  }\n}\n\n/**\n * var page_count - Calculates the number of pages in a result set\n *\n * @param  {Integer} results  Integer representing total number of results\n * @param  {Integer} per_page Integer representing total number of results per page\n * @return {Integer}          Integer representing total number of pages\n */\nvar page_count = function(results, per_page) {\n  if (!per_page) { per_page = 10 }\n  var result = results/per_page\n  if (results % per_page) { return Math.floor(result) + 1 }\n  else { return result }\n}\n\n/**\n * _url_for - Returns a url for a particular query type & params\n *\n * @param  {String} query_type Type of query you are interested in making\n * @param  {Object} params     Arguments for the url endpoint\n * @return {String}            URL for endpoint\n */\nvar url_for = function(query_type, params) {\n  var builder = new UrlBuilder(query_type, params)\n  return builder.build()\n}\n\n/**\n * image_url - Builds an image url using the template url in a stream object\n *\n * @param  {Object} stream Stream object from results set.\n * @return {String}        URL to use as an image thumbnail for a string\n */\nvar image_url = function(stream) {\n  if (stream.preview.template) {\n    var result  = stream.preview.template.replace(\"{width}\", 125)\n    result      = result.replace(\"{height}\", 125)\n    return result\n  }\n  return \"http://via.placeholder.com/125x125\"\n}\n\n\n/**\n * build_result - This will build an html partial for use in populating a result set\n *\n * @param  {Object} stream Object representing a stream.\n * @return {String}        HTML partial with populated fields\n */\nvar build_result = function(stream) {\n  var template =\n  `<div class=\"result\">\n    <img class='stream-img' src=\"${image_url(stream)}\"/><h1>${stream.channel.display_name}</h1>\n    <h2>${stream.game} - ${stream.viewers} Viewers</h2>\n    <p>${stream.channel.status}</p>\n  </div>`\n  return template\n}\n\n\n/**\n * var error_template - This will build an html partial for use in populating an error message\n *\n * @param  {String} error_msg Message describing the error\n * @return {String}           HTML partial with populated fields\n */\nvar error_template = function(error_msg) {\n  var template =\n  `<div class='error'>\n    <h1>Something went wrong...</h1>\n    <p>${error_msg}</p>\n    <p>Please try again.</p>\n  </div>\n  `\n  return template\n}\n\n/**\n * UrlBuilder - Builder used for constructing urls\n *\n * @param  {String} query_type String key for query type to build\n * @param  {Object} params     Arguments for the api endpoint\n * @return {Object}            Prototype object with `build` function\n */\nfunction UrlBuilder(query_type, params) {\n  this.proto  = 'https'\n  this.host   = 'api.twitch.tv'\n  if (routes[query_type]) {\n    this.path = routes[query_type].path\n  }\n  this.params = params\n}\n\n/**\n * params_to_string - Converts a dictionary to query params usable with a url\n *\n * @param  {Object} dict Dictionary containing the key/values to be used as params\n * @return {String} A string representing the params\n */\nvar params_to_string = function(dict) {\n  return Object.entries(dict).map(function(kv){\n    return kv.map(encodeURIComponent).join('=')\n  }).join('&')\n}\n\n/**\n * UrlBuilder.prototype.build - Builds a URL\n *\n * @return {String}  URL for use with http client\n */\nUrlBuilder.prototype.build = function() {\n  var url = `${this.proto}://${this.host}/${this.path}`\n  if (this.params) {\n    url = `${url}?${params_to_string(this.params)}`\n  }\n  return url\n}\n\n/**\n * var string_to_hash - Poorman's string hash.  Used to create a finger print for strings we can use for keying jsonp requests/state\n *\n * @param  {String} str A string with some type of information in it\n * @return {String}     A hash of the string that was input\n */\nvar string_to_hash = function(str) {\n  var hash = 0\n  if (str.length <= 0) { return hash }\n\n  for (var i = 0; i < str.length; i++) {\n    var char = str.charCodeAt(i)\n    hash     = (hash << 5) - char\n    hash     = hash + hash\n  }\n  return hash.toString()\n}\n\n/// Make available to the test harness\nmodule.exports = {\n  App: App,\n  url_for: url_for,\n  image_url: image_url,\n  page_count: page_count,\n  string_to_hash: string_to_hash,\n  buildPagerLinks: buildPagerLinks,\n  parseOffsetFromLink: parseOffsetFromLink,\n}\n\n/// Make available to the browser window for initialization\nif (typeof window !== 'undefined') {\n  window.App = App\n}\n"]}